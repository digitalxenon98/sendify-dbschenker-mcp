# DB Schenker CAPTCHA Challenge-Response Architecture

## Overview

The DB Schenker public tracking endpoint (`/nges-portal/api/public/tracking-public/`) implements a **browser-bound challenge-response mechanism** rather than a traditional API key authentication flow. This architectural choice means the endpoint cannot be accessed reliably via server-side HTTP clients without browser execution.

## Challenge-Response Flow

### 1. Initial Request (Without Solution)

When a client makes a request without a valid `Captcha-Solution` header:

```
GET /nges-portal/api/public/tracking-public/shipments?query=1806203236
```

**Response:**
- **Status:** `429 Too Many Requests`
- **Header:** `Captcha-Puzzle: <base64-encoded-challenge>`
- **Body:** Empty or error message

This indicates the server requires a CAPTCHA solution before processing the request.

### 2. Challenge Structure

The `Captcha-Puzzle` header contains a base64-encoded challenge that must be solved client-side. The solution is **session and timing dependent**:

- Each challenge is unique per request/session
- Solutions expire quickly (typically seconds to minutes)
- The same reference number will generate different challenges on different requests
- Solutions cannot be reused or cached across requests

### 3. Solution Generation

The solution is generated by JavaScript code in the tracking web application:

- **Location:** Bundled in `main.*.js` (e.g., `cdn/main.6774dda48fc0a866.js`)
- **Algorithm:** The bundle contains a CAPTCHA solving algorithm that:
  - Intercepts API requests via fetch/XMLHttpRequest
  - Detects `Captcha-Puzzle` headers in responses
  - Solves the challenge using client-side logic
  - Generates the solution in the required format
  - Automatically adds `Captcha-Solution` header to subsequent requests
- **Process:** 
  1. Browser receives `Captcha-Puzzle` header
  2. JavaScript intercepts the response (via request interceptor)
  3. Client-side algorithm solves the challenge
  4. Solution is encoded as base64 JSON array
  5. Solution is added to subsequent requests as `Captcha-Solution` header

**Note:** The algorithm was originally designed to run in a browser context. However, our implementation uses a pure JavaScript proof-of-work algorithm that solves CAPTCHA puzzles server-side without requiring browser automation.

### 4. Solution Format

The `Captcha-Solution` header is a base64-encoded JSON array:

```json
[
  { "jwt": "...", "solution": "..." },
  { "jwt": "...", "solution": "..." },
  ...
]
```

### 5. Successful Request (With Valid Solution)

When a request includes a valid `Captcha-Solution` header:

```
GET /nges-portal/api/public/tracking-public/shipments?query=1806203236
Headers:
  Captcha-Solution: <base64-encoded-solution>
  Cookie: <session-cookies>
```

**Response:**
- **Status:** `200 OK`
- **Body:** JSON shipment data

### 6. Invalid Solution

When a request includes an expired or invalid `Captcha-Solution`:

**Response:**
- **Status:** `422 Unprocessable Entity`
- **Body:** `"Invalid solution"` or similar error message

This indicates the solution was malformed, expired, or doesn't match the current challenge.

## Why This is Browser-Bound

1. **JavaScript Execution Required:** The solution generation logic is embedded in browser JavaScript and requires DOM/Web APIs
2. **Session Context:** Solutions are tied to browser session cookies and timing
3. **Dynamic Generation:** Each challenge is unique and time-sensitive
4. **Anti-Bot Design:** The mechanism is intentionally designed to prevent server-side automation

## Implications for Server-Side Clients

- **Direct HTTP requests fail** without browser execution
- **Static solutions don't work** - each request needs a fresh solution
- **Session cookies alone are insufficient** - the `Captcha-Solution` header is required
- **Solutions expire quickly** - cannot be reused across requests

## Architectural Boundary

This represents a **hard system boundary** rather than a transient failure:

- **Not retryable** - retrying with the same solution will fail
- **Not rate limiting** - 429 with `Captcha-Puzzle` is a challenge, not throttling
- **Requires browser execution** - cannot be solved server-side
- **Session-dependent** - solutions are tied to browser session state

## Our Implementation

Our implementation uses a pure JavaScript proof-of-work algorithm that:

- ✅ **Solves CAPTCHA puzzles server-side** using Node.js
- ✅ **No browser automation required** - runs entirely in Node.js
- ✅ **Automatic and transparent** - solves puzzles when encountered
- ✅ **Respects the challenge-response mechanism** - generates valid solutions

### How Our Algorithm Works

1. Receives `Captcha-Puzzle` header in HTTP 429 response
2. Parses the puzzle data from the JWT payload
3. Calculates target value from puzzle bytes
4. Finds valid nonce using proof-of-work (double SHA-256)
5. Generates `Captcha-Solution` header in the required format
6. Retries request with solution header

This approach solves CAPTCHA puzzles algorithmically without requiring browser execution or automation.

