# System Boundaries & Technical Considerations

## CAPTCHA Protection Mechanism

The DB Schenker tracking endpoint (`/nges-portal/api/public/tracking-public`) is protected by browser-level CAPTCHA mechanisms. This is not a public API in the traditional sense, but rather a browser-protected service that requires client-side CAPTCHA solving.

When requests are made from a browser, a dynamically generated `Captcha-Solution` header is included. This token is produced client-side as part of an anti-bot challenge and cannot be generated by a server-side client.

If the required `Captcha-Solution` header is missing, the upstream service responds deterministically with HTTP 429 and a `Captcha-Puzzle` response header. This response indicates an enforced system boundary rather than transient rate limiting.

### How CAPTCHA Protection Works

- The upstream service requires a `Captcha-Solution` header that can only be generated by a browser executing JavaScript-based CAPTCHA challenges.
- Server-side requests without this header receive HTTP 429 responses with a `Captcha-Puzzle` response header.
- This is a deterministic, intentional system boundary, not a transient failure or rate limit.

## System Behavior

### CAPTCHA Detection & Handling

- **CAPTCHA Detection**: The client detects CAPTCHA challenges by checking for HTTP 429 responses combined with the presence of `Captcha-Puzzle` headers.
- **Automatic Solving**: When a CAPTCHA challenge is detected, the server automatically solves it using a proof-of-work algorithm and retries the request with the solution. This happens transparently without user intervention.
- **Error Handling**: If CAPTCHA solving fails or the solution is rejected (HTTP 422), the system returns structured error responses:
  - `CAPTCHA_SOLUTION_INVALID` (422): Solution was rejected (expired/invalid) - retryable
  - `status: "blocked"` (429): CAPTCHA solving failed or puzzle couldn't be solved - non-retryable
- **Failure Caching**: CAPTCHA-blocked results (when solving fails) are cached for 60 seconds to avoid repeated upstream requests for the same reference number.

## CAPTCHA Solving

The current implementation automatically solves CAPTCHA puzzles using a proof-of-work algorithm:

- **Automatic CAPTCHA Solving**: When a CAPTCHA challenge is detected (HTTP 429 with `Captcha-Puzzle` header), the server automatically solves it using a proof-of-work algorithm and retries the request with the solution.
- **No Browser Automation**: The server does not use any browser automation tools. CAPTCHA solving is done purely algorithmically using JavaScript.
- **Transparent Operation**: CAPTCHA solving happens automatically and transparently - no manual intervention is required.
- **Graceful Error Handling**: If CAPTCHA solving fails or solutions are rejected, the system returns structured error responses.

## Retry Semantics & Rate Limiting

The implementation includes retry mechanisms for transient server errors, but distinguishes between retryable failures and hard system boundaries:

- **Exponential Backoff for Transient Errors**: Transient server errors (HTTP 5xx) are retried using exponential backoff, providing up to 3 retry attempts with increasing delays. This applies only to genuine transient failures.

- **CAPTCHA Blocking vs. Rate Limiting**: HTTP 429 responses are handled differently based on their cause:
  - **CAPTCHA-related HTTP 429**: Detected and automatically solved. If solving fails, returns a structured "blocked" response (non-retryable).
  - **True rate limiting**: If a 429 occurs without CAPTCHA headers (unlikely but possible), it may be retried with exponential backoff as a transient rate limit.

- **Response Caching**: Successful responses are cached in memory for a short period (currently 60 seconds) to reduce upstream load and avoid unnecessary repeated calls.

- **Graceful Error Handling**: The tool returns clear, structured error messages that distinguish between different failure modes, allowing downstream consumers to make informed decisions about retry behavior.

By differentiating these cases, the system remains resilient while respecting upstream constraints and usage boundaries.

## Production Considerations

A real production solution would require one of the following approaches:

- An official DB Schenker API with proper authentication
- A partner integration program with DB Schenker
- Explicit user-initiated browser flows where users solve CAPTCHA challenges themselves

