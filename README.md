# DB Schenker Shipment Tracker MCP Server

An MCP (Model Context Protocol) server that tracks DB Schenker shipments by reference number, providing structured shipment information including sender/receiver details, package information, and complete tracking history.

**Important**: The DB Schenker tracking endpoint is protected by browser-level CAPTCHA. Server-side requests are intentionally treated as operating against a hard system boundary rather than a generic public API.

## Setup Instructions

### Prerequisites

- **Node.js**: Version 18 or higher
- **npm**: Comes bundled with Node.js

### Environment Setup

1. **Clone or download this repository**
   ```bash
   git clone https://github.com/digitalxenon98/sendify-dbschenker-mcp
   cd sendify-dbschenker-mcp
   ```

2. **Verify Node.js installation**
   ```bash
   node --version  # Should be v18 or higher
   npm --version
   ```

## Build/Install Dependencies

1. **Install all dependencies**
   ```bash
   npm install
   ```

   This will install:
   - Runtime dependencies: `@modelcontextprotocol/sdk`, `zod`
   - Development dependencies: `typescript`, `tsx`, `@types/node`

2. **Build the TypeScript project** (optional, for production)
   ```bash
   npm run build
   ```

   This compiles TypeScript to JavaScript in the `dist/` directory.

## How to Run the MCP Server

### Development Mode

Run the server directly with TypeScript (no build required):

```bash
npm run dev
```

The server will start and communicate via stdio (standard input/output), which is the standard way MCP servers operate.

### Production Mode

1. First, build the project:
   ```bash
   npm run build
   ```

2. Then run the compiled JavaScript:
   ```bash
   npm start
   ```

### MCP Client Configuration

To use this MCP server with an MCP client (like Claude Desktop), add it to your MCP configuration:

```json
{
  "mcpServers": {
    "db-schenker-tracker": {
      "command": "node",
      "args": ["/path/to/sendify-dbschenker-mcp/dist/server.js"]
    }
  }
}
```

For development, you can use `tsx` instead:

```json
{
  "mcpServers": {
    "db-schenker-tracker": {
      "command": "tsx",
      "args": ["/path/to/sendify-dbschenker-mcp/src/server.ts"]
    }
  }
}
```

## How to Test the Tool

### Using an MCP Client

1. **Start your MCP client** (e.g., Claude Desktop) with the server configured
2. **Call the tool** with a reference number:
   ```
   track_shipment(reference: "1806203236")
   ```

### Example Reference Numbers

You can test with these reference numbers:

- `1806203236`
- `1806290829`
- `1806273700`
- `1806272330`
- `1806271886`

### Expected Response Format

**Success Response:**
```json
{
  "ok": true,
  "reference": "1806203236",
  "shipment": {
    "id": "...",
    "stt": "...",
    "transportMode": "LAND",
    ...
  },
  "sender": {...},
  "receiver": {...},
  "packageDetails": {...},
  "trackingHistory": [...],
  ...
}
```

**Error Response (Not Found):**
```json
{
  "ok": false,
  "error": "NOT_FOUND",
  "message": "No shipment found for that reference number.",
  "reference": "1806203236"
}
```

**Error Response (API Error):**
```json
{
  "ok": false,
  "error": "API_ERROR",
  "message": "Failed to fetch shipment data from DB Schenker API.",
  "reference": "1806203236",
  "details": "HTTP 429 Too Many Requests...",
  "hint": "The upstream service rejected the request. Retry behavior depends on the failure type."
}
```

**Error Response (CAPTCHA Blocked):**
```json
{
  "status": "blocked",
  "retryable": false,
  "reason": "Upstream service requires browser CAPTCHA",
  "details": "This endpoint is protected by anti-bot measures and cannot be accessed server-side.",
  "upstream": {
    "url": "...",
    "status": 429,
    "hasCaptchaPuzzleHeader": true
  }
}
```

### Manual Testing (Node.js)

You can also test the server manually by sending MCP protocol messages via stdio, though this requires understanding the MCP protocol format.

## CAPTCHA & System Boundary Considerations

The DB Schenker tracking endpoint (`/nges-portal/api/public/tracking-public`) is protected by browser-level CAPTCHA mechanisms. This is not a public API in the traditional sense, but rather a browser-protected service that requires client-side CAPTCHA solving.

Although the DB Schenker tracking endpoints appear to be publicly accessible, closer inspection shows that they are protected by a browser-level CAPTCHA mechanism.

When requests are made from a browser, a dynamically generated `Captcha-Solution` header is included. This token is produced client-side as part of an anti-bot challenge and cannot be generated by a server-side client.

If the required `Captcha-Solution` header is missing, the upstream service responds deterministically with HTTP 429 and a `Captcha-Puzzle` response header. This response indicates an enforced system boundary rather than transient rate limiting.

### How CAPTCHA Protection Works

- The upstream service requires a `Captcha-Solution` header that can only be generated by a browser executing JavaScript-based CAPTCHA challenges.
- Server-side requests without this header receive HTTP 429 responses with a `Captcha-Puzzle` response header.
- This is a deterministic, intentional system boundary, not a transient failure or rate limit.

### System Behavior

- **CAPTCHA Detection**: The client detects CAPTCHA blocking by checking for HTTP 429 responses combined with the presence of `Captcha-Puzzle` headers.
- **Non-Retryable Failures**: CAPTCHA-related HTTP 429 responses are treated as non-retryable. No exponential backoff or retry logic is applied, as retrying would not resolve the missing CAPTCHA solution.
- **Fail Fast**: The client fails fast instead of retrying or backing off when CAPTCHA is detected.
- **Structured Error Response**: The limitation is surfaced clearly through structured error responses with `status: "blocked"` and `retryable: false`, clearly distinguishing this from transient failures.
- **Failure Caching**: CAPTCHA-blocked results are cached for 60 seconds to avoid repeated upstream requests for the same reference number.

### Ethical Boundaries

This implementation explicitly respects CAPTCHA protections as a system boundary:

- **No CAPTCHA Bypass**: No attempt is made to bypass, automate, or solve CAPTCHA challenges.
- **No Browser Automation**: No browser automation tools (Playwright, Puppeteer, Selenium) are used.
- **No Token Replay**: No hard-coded tokens or header replay mechanisms are employed.
- **Fail Fast**: The system fails gracefully and immediately when CAPTCHA blocking is detected, rather than attempting workarounds.

This approach reflects correct and ethical engineering practice and avoids interacting with the upstream service in unsupported or brittle ways.

### Production Considerations

A real production solution would require one of the following approaches:

- An official DB Schenker API with proper authentication
- A partner integration program with DB Schenker
- Explicit user-initiated browser flows where users solve CAPTCHA challenges themselves

## Rate Limiting & Reliability

The implementation includes retry mechanisms for transient server errors, but distinguishes between retryable failures and hard system boundaries:

- **Exponential Backoff for Transient Errors**: Transient server errors (HTTP 5xx) are retried using exponential backoff, providing up to 3 retry attempts with increasing delays. This applies only to genuine transient failures.

- **CAPTCHA Blocking vs. Rate Limiting**: HTTP 429 responses are handled differently based on their cause:
  - **CAPTCHA-related HTTP 429**: Detected and treated as a hard, non-retryable boundary. The client fails fast and returns a structured \"blocked\" response.
  - **True rate limiting**: If a 429 occurs without CAPTCHA headers (unlikely but possible), it may be retried with exponential backoff as a transient rate limit.

- **Response Caching**: Successful responses are cached in memory for a short period (currently 60 seconds) to reduce upstream load and avoid unnecessary repeated calls.

- **Graceful Error Handling**: The tool returns clear, structured error messages that distinguish between different failure modes, allowing downstream consumers to make informed decisions about retry behavior.

By differentiating these cases, the system remains resilient while respecting upstream constraints and usage boundaries.


